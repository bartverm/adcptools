function [VEL,BTVEL] = filterADCP(inadcp,varargin)
%FILTERADCP2  
%         [VEL,btvel]=filterADCP(INADCP, FLAGS) transforms the input
%         velocities by filtering with specified filters in FLAGS and
%         outputs this data in VEL and btvel. 
%         
%         INADCP is an adcp structure as generated by readadcp2
%         FLAGS is a character array that indicates the type of filtering:
%         f false target
%         e high error velocity
%         c low correlation
%         b bottom/surface detection
%
%         [VEL,btvel]=filterADCP(..., 'PropertyName',PropertyValue)
%         transform the input velocities by filtering, and allows to
%         specify the following additional settings:
%
%         echotres
%         echo intensity threshold above which a peak is defined when
%         removing bottom/surface removal
%
%         stdEcho
%         number of standard deviations above which difference between echo
%         intensities corrected for spreading losses and the mean is high
%         enough to be rejected (for bottom/surface detection)
%
%         difecho
%         threshold above which difference between echo intensities for all
%         beams and the mean is high enough to be rejected
%
%         cortres
%         threshold in low correlation
%
%         erveltres
%         threshold in error velocity
%
%         SLobeFact
%         factor to increase sidelobe effect
%
%         NF
%         near-field range
%         
%         filterBT
%         Bottom Track filtering
%
%         EnsRange
%         Two Element vector containing the ensmble range to process.
%         Default is the whole dataset
% 
%         EnsAvging
%         not implemented yet
%
%         fisHADCP
%         true | {false} Indicates if the data comes from a HADCP
% 
%         Example:
%         [adcp.VEL,adcp.btvel]=filterADCP2(adcp,'fc','cortres',75) will
%         transform velocity data by filtering with false target and low
%         correlation magnitude using a correlation threshold of 75
%
%         Notes: By default, difecho = 50, cortres = 64, erveltres = 0.8
%                m/s
%                Choose configuration corresponding to maximum number of
%                bins when processing variable configuration files.
%

%    Copyright 2009 Bart Vermeulen, Maximiliano Sassi
%
%    This file is part of ADCPTools.
%
%    ADCPTools is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    ADCPTools is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with ADCPTools.  If not, see <http://www.gnu.org/licenses/>.

%         Last edit:   09-07-2009 - add filter based on heading
%                                   add filter based on SL for HADCP
%                                   (bottom and surface removal)   

%% Parsing input
P=inputParser;
P.FunctionName='filterADCP';
P.addRequired('inadcp',@isstruct)
P.addOptional('flags','fecb',@ischar)

P.addParamValue('stdEcho',4,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('EnsRange',[0 0],@(x) isnumeric(x) && numel(x)==2)
%P.addParamValue('EnsAvging',1,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('echotres',5,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('difecho',50,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('cortres',64,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('erveltres',800,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('SLobeFact',1,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('NF',0,@(x) isnumeric(x) && numel(x)==1);
P.addParamValue('filterBT',true,@(x) islogical(x) && numel(x)==1);
P.addParamValue('fIsHadcp',false,@(x) islogical(x) && numel(x)==1)

P.parse(inadcp,varargin{:})

EnsRange=P.Results.EnsRange;
%EnsAvging=P.Results.EnsAvging;
%echotres=P.Results.echotres;
deltaPeak = P.Results.echotres;
difecho=P.Results.difecho;
cortres=P.Results.cortres;
erveltres=P.Results.erveltres;
fIsHadcp=P.Results.fIsHadcp;
flags=P.Results.flags;
stdEcho=P.Results.stdEcho;
SLobeFact=P.Results.SLobeFact;
filterBT=P.Results.filterBT;
NF=P.Results.NF;
defaultInput=P.UsingDefaults;
clear P

%% Check the fixed leader
%When the Fixed leader of the files differ, all setting are recorded once
%for each file. Sensitive parameters are the number of bins (because the
%variable leaders involving depth cell information will change in size) and
%any change in system or coordinate configuration.
nValidFiles = numel(inadcp.firmver);
if ~CheckFL(nValidFiles,inadcp)                                            % If configuration in fixed leader changes
%     warning('filterADCP2:ConfigChange',...                                   % Generate warning
%         'The configuration seems to have changed between files. \n Using filterADCP2 with maximum bin size') 
    idx = find(inadcp.nbins == max(inadcp.nbins),1,'first');                   % Create index for variable fixed leaders
else
    idx = 1;
end

nens=size(inadcp.VEL,2);                                                   %Find number of ensembles
%nbins=double(inadcp.nbins(idx));                                           %Get the number of bins
nbins = size(inadcp.VEL,1);
if isequal(EnsRange,[0 0])
    EnsRange = [1 nens];
end
EnsInRange=EnsRange(1):EnsRange(2);

filterBT=filterBT & isfield(inadcp, 'btvel'); % check when filtering BT that BT field is in input data
clear EnsRange

if nargout == 2 && ~filterBT    % function is called with two output arguments when BT is not existing
    tempVELBT = nan;
end

%% Converting to double and removing bad velocities
ffVEL=inadcp.VEL(:,EnsInRange,:)==-32768;
tempVEL = double(inadcp.VEL(:,EnsInRange,:))/1000;
tempVEL(ffVEL)=NaN;
if filterBT
    ffBTVEL=inadcp.btvel(EnsInRange,:)==-32768;
    tempVELBT = double(inadcp.btvel(EnsInRange,:))/1000;
    tempVELBT(ffBTVEL)=NaN;
end

% if strfind(options,'a')
%     tempV1 = avADCP(tempV1,average);
% end
%nbins=size(tempVEL,1);

%% False target removing
if fIsHadcp
    nbeams=3;
else
    nbeams=4;
end
% False target is always determined as it is required for bottom filtering
FalseTargetFilt = abs(double(inadcp.ECHO(:,EnsInRange,1:nbeams))-repmat(mean(inadcp.ECHO(:,EnsInRange,1:nbeams),3),[1,1,nbeams]))>difecho;
% if filterBT
%     FalseTargetFiltBT=(abs(double(inadcp.btecho(EnsInRange,1:nbeams))-repmat(mean(inadcp.ECHO(EnsInRange,1:nbeams),2),[1,nbeams]))>difecho)';
%     FalseTargetFilt= FalseTargetFilt & repmat(reshape(FalseTargetFiltBT,[1,length(EnsInRange),nbeams]),[nbins,1,1]);
% end
if any(regexpi(flags,'f'))
    %Filtering for high intensity with respect to OTHER BEAMS (in same bin)
    if ~strcmp(inadcp.corinfo(idx,4:5),'00')         %If it's not beam coordinates remove all velocity components
        isBadEns=repmat(any(FalseTargetFilt,3),[1,1,4]); %for HADCP remove all components and the null component (it's useless anyway)
%         if filterBT
%             isBadEnsBT=repmat(any(FalseTargetFiltBT,2),[1,4]); %for HADCP remove all components and the null component (it's useless anyway)          
%         end
    else
        isBadEns=FalseTargetFilt;
%         if filterBT, isBadEnsBT=FalseTargetFiltBT; end
    end
    %Setting bad velocities to NaN
    tempVEL(isBadEns) = NaN;
%     if filterBT, tempVELBT(isBadEnsBT) = NaN; end
end
clear isBadEns

%% Low correlation filtering
if any(strfind(flags,'c'))
    isBadEns = inadcp.CORR(:,EnsInRange,:)<cortres;
    if filterBT
        isBadEnsBT=inadcp.btcor(EnsInRange,:) <cortres;
        isBadEns=isBadEns & repmat(reshape(isBadEnsBT,[1,length(EnsInRange),4]),[nbins,1,1]);
    end
    %Setting bad velocities to NaN
    if ~strcmp(inadcp.corinfo(idx,4:5),'00')         %If it's not beam coordinates remove all velocity components
        isBadEns=repmat(any(isBadEns,3),[1,1,4]);
        if filterBT
            isBadEnsBT=repmat(any(isBadEnsBT,2),[1,4]); %for HADCP remove all components and the null component (it's useless anyway) 
        end
    end
    tempVEL(isBadEns) = NaN;
    if filterBT
        tempVELBT(isBadEnsBT) = NaN;
    end
end

%% High error velocity filtering
if any(strfind(flags,'e'))
    if strcmp(inadcp.corinfo(idx,4:5),'00')
        warning('filterADCP2:BeamCor','Data in beam coordinates; no error velocity filtering possible')
    else
        isBadEns = repmat(abs(tempVEL(:,:,4)) > erveltres,[1,1,4]);
        if filterBT
            isBadEnsBT=abs(tempVELBT(:,4))' > erveltres;
            isBadEns=isBadEns & repmat(isBadEnsBT,[nbins,1,4]);
            tempVELBT(isBadEnsBT) = NaN;
        end
        tempVEL(isBadEns) = NaN;
    end
end

%% Bottom/surface removal
if any(strfind(flags,'b'))
    % Determine near-field range and beam angle
    bangle=0;
    if any(strcmp(defaultInput,'NF'))
        switch inadcp.sysconf(idx,1:3)
            case '000'
                NF=2*3.15; % 75 KHz
            case '100'
                NF=2*2.19; % 150 KHz
            case '010'
                NF=2*2.84; % 300 KHz
            case '110'
                NF=2*3.28; % 600 KHz
            case '001'
                NF=2*1.88; % 1200 KHz
        end
    end
    if fIsHadcp
        bangle=max(double(inadcp.HADCPbeamangle));
    else
        switch inadcp.sysconf(idx,9:10)
            case '00'
                bangle=15;
            case '10'
                bangle=20;
            case '11'
                bangle=30;
        end
    end
    if bangle==0;
        warning('filterADCP2:UnknownBangle','Beam angle unclear, assuming 20 degrees')
        bangle=20;
    end
    if NF==0
        warning('filterADCP2:UnknownNF','Near field range unclear, assuming 1.88 m')
        NF=1.88;
    end
%     if fIsHadcp
%         nbeams=3;
%     else
%         nbeams=4;
%     end

    % Determine Range of the cells
    distmidbin1=double(inadcp.distmidbin1)/100;                       %Get the distance of the middle of the first bin
    binsize=double(inadcp.binsize)/100;                               %Get the binsize
    FileNumber=repmat(inadcp.FileNumber,[nbins,1,nbeams]);                 %Replicate the Number of dataset to the bins
    BinDist=distmidbin1(FileNumber)+repmat((0:nbins-1)',[1,nens,nbeams]).*...
        binsize(FileNumber);                                               %Calculate distance to each measured cell
    logr2=log(BinDist.^2);                                                 %Calculate spreading loss
    
    % Find peaks in echo intensity (corrected for spreading losses) by using peakdet
    EchoFilt = false(nbins,nens,nbeams);                                   % initialize with false    
    CorrEcho = double(inadcp.ECHO(:,:,1:nbeams))-logr2;
    maxtab = peakdet(CorrEcho,deltaPeak);
    EchoFilt(maxtab(:,1)) = true;
    clear maxtab CorrEcho                                                  % clean some memory    
    EchoFilt=EchoFilt & (BinDist-binsize(FileNumber)/2 > NF);                          %Ignore the near field
    EchoFilt=EchoFilt & (~FalseTargetFilt);                                %Remove false targets (they might be detected as bottom/surface backscatter

% Find peaks in echo corrected for spreading losses by computing 2nd
% order difference
%     CorrEcho=abs(diff(double(inadcp.ECHO(:,:,1:nbeams))-logr2,2,1));
%     mCorrEcho=repmat(mean(CorrEcho,1),[size(CorrEcho,1),1,1]);
%     stdCorrEcho=repmat(std(CorrEcho,0,1),[size(CorrEcho,1),1,1]);
%     EchoFilt=abs(CorrEcho-mCorrEcho)>(stdEcho*stdCorrEcho);                %Mark bad all data with high 2nd order derivative
%     EchoFilt=EchoFilt & (BinDist(2:end-1,:,:)-binsize(1)/2>NF);               %Ignore the near field
%     EchoFilt=EchoFilt & (~FalseTargetFilt(2:end-1,:,:));                   %Remove false targets (they might be detected as bottom/surface backscatter
    
    % Remove bad bins and correct for sidelobe effect
    slobeClear=cosd(bangle);
    slobeClear=1-SLobeFact+SLobeFact*slobeClear;                           %Apply a factor to increase sidelobe effect
    for cntdm=1:nbeams
        if fIsHadcp && cntdm==3                                            %For a HADCP the third beam has a beam-angle of 0 and therefore needs no slobe correction
            for cntcol=1:nens
                startBad=find(EchoFilt(:,cntcol,cntdm),1,'first');
                if ~isempty(startBad)
                    EchoFilt(startBad:end,cntcol,cntdm)=true;
                end
            end
        else
            for cntcol=1:nens
                startBad=find(EchoFilt(:,cntcol,cntdm),1,'first');
                if ~isempty(startBad)
                    if startBad < nbins
                        startBad=find(BinDist(:,cntcol,cntdm)>(slobeClear*BinDist(startBad+1,cntcol,cntdm)),1)-1;
                    else
                        startBad=find(BinDist(:,cntcol,cntdm)>(slobeClear*BinDist(startBad,cntcol,cntdm)),1)-1;
                    end                        
                    EchoFilt(startBad:end,cntcol,cntdm)=true;
                end
            end
        end    
    end
    
%     EchoFilt=cat(1,EchoFilt(1,:,:),EchoFilt,EchoFilt(end,:,:));
    if ~strcmp(inadcp.corinfo(4:5),'00')                                   %If it's not beam coordinates remove all velocity components
        isBadEns=repmat(any(EchoFilt,3),[1,1,4]);                          %for HADCP remove all components and the null component (it's useless anyway)
    else
        isBadEns=EchoFilt;
    end
    tempVEL(isBadEns) = NaN;                                               %Setting bad velocities to NaN
end

%Outputting data
VEL=tempVEL;
if nargout==2
    BTVEL=tempVELBT;
end

%%          FUNCTION TO CHECK DIFFERENCES IN FIXED LEADER (from readadcp2)
function issame=CheckFL(nValidFiles,dataout)

issame=true;                                                               % Initialize result as true
if nValidFiles<2                                                           % If less than two files
    issame=true;                                                           % Return true
    return                                                                 % Exit function (Nothing to check!!)
end
for cntfiles=2:nValidFiles                                                 % Loop for all files
    issame=issame &&...                                                    % Check if any of the variables changes
        isequal(dataout.firmver(1),dataout.firmver(cntfiles))&&...
    isequal(dataout.firmrev(1),dataout.firmrev(cntfiles))&&...
    isequal(dataout.sysconf(1,:),dataout.sysconf(cntfiles,:))&&...
    isequal(dataout.SymData(1),dataout.SymData(cntfiles))&&...
    isequal(dataout.LagLength(1),dataout.LagLength(cntfiles))&&...
    isequal(dataout.usedbeams(1),dataout.usedbeams(cntfiles))&&...
    isequal(dataout.nbins(1),dataout.nbins(cntfiles))&&...
    isequal(dataout.pingperens(1),dataout.pingperens(cntfiles))&&...
    isequal(dataout.binsize(1),dataout.binsize(cntfiles))&&...
    isequal(dataout.blnk(1),dataout.blnk(cntfiles))&&...
    isequal(dataout.minthrsh(1),dataout.minthrsh(cntfiles))&&...
    isequal(dataout.ncodrep(1),dataout.ncodrep(cntfiles))&&...
    isequal(dataout.minpercgood(1),dataout.minpercgood(cntfiles))&&...
    isequal(dataout.maxerrvel(1),dataout.maxerrvel(cntfiles))&&...
    isequal(dataout.Tbetweenpng(1),dataout.Tbetweenpng(cntfiles))&&...
    isequal(dataout.corinfo(1,:),dataout.corinfo(cntfiles,:))&&...
    isequal(dataout.headalign(1),dataout.headalign(cntfiles))&&...
    isequal(dataout.headbias(1),dataout.headbias(cntfiles))&&...
    isequal(dataout.sensource(1,:),dataout.sensource(cntfiles,:))&&...
    isequal(dataout.senavail(1,:),dataout.senavail(cntfiles,:))&&...
    isequal(dataout.distmidbin1(1),dataout.distmidbin1(cntfiles))&&...
    isequal(dataout.lngthtranspulse(1),dataout.lngthtranspulse(cntfiles))&&...
    isequal(dataout.watrefbins(1,:),dataout.watrefbins(cntfiles,:))&&...
    isequal(dataout.mintarget(1),dataout.mintarget(cntfiles))&&...
    isequal(dataout.lowlattrig(1),dataout.lowlattrig(cntfiles))&&...
    isequal(dataout.distpulse(1),dataout.distpulse(cntfiles))&&...
    isequal(dataout.cpuserial(1,:),dataout.cpuserial(cntfiles,:))&&...
    isequal(dataout.bandwidth(1),dataout.bandwidth(cntfiles))&&...
    isequal(dataout.syspower(1),dataout.syspower(cntfiles))&&...
    isequal(dataout.basefreqid(1),dataout.basefreqid(cntfiles))&&...
    isequal(dataout.serial(1,:),dataout.serial(cntfiles,:))&&...
    isequal(dataout.HADCPbeamangle(1),dataout.HADCPbeamangle(cntfiles));
    if issame==false
        break
    end
end
