function [VEL,btvel]=corADCP(inadcp, DestCor, varargin)
%CORADCP  
%         [VEL,btvel]=coradcp(INADCP, DESTCOR) transforms the input
%         velocities into a new coordinate system and outputs this data in
%         VEL and btvel. 
%         
%         INADCP is a adcp structure as generated by readadcp2
%         DESTCOR is a character that indicates the destination coordinate
%         system:
%         b transform to beam coordinates
%         i transform to instrument coordinates
%         s transform to ship coordinates
%         e transform to earth coordinates
%
%         [VEL,btvel]=coradcp(..., 'PropertyName',PropertyValue) trasnform the
%         input velocities to a new coordinate system, and allows to
%         specify the following additional settings:
%
%         isHADCP
%         true | {false} Indicates if the data comes from a HADCP
%        
%         CalMatrix
%         A 4x4 matrix to transform beam to instrument coordinates. This is
%         usefull to give the function a calibration matrix (This is
%         obtained from the ADCP with the PS3 command and accounts for
%         small deviations of the beam-angles). By default the function
%         calculates this matrix based on the design beam-angle (not the
%         exact ones!)
%         
%         OwnMatrix
%         A 4x4 matrix to perform a custom linear computation on the
%         velocities. If given, the function multiplies all the velocity
%         vectors with the matrix and outputs the results. All other
%         properties and the DESTCOR parameter are ignored.
% 
%         BeamAngle
%         Sets the angle between the axis of the instrument and the beams.
%         If this is not given the angle is read from the ADCP data.
%
%         IsUpward
%         true | false Sets if the instrumen is up or downlooking. This
%         setting has no influence if isHADCP is set to true. By default
%         this value is read from the adcp
% 
%         UseTilts
%         {true} | false For forward transformations (from beam to others)
%         sets if tilts have to be used. For backward transformations (to 
%         beam) the ADCP settings are used.
% 
%         HeadAlign
%         Sets the heading alignment (see ADCP manuals). By default this
%         setting is read from the data.
%
%         HeadBias
%         Sets the heading bias (see ADCP manuals). By default this setting
%         is read from the data.
%
%         EnsRange
%         Two Element vector containing the ensmble range to process.
%         Default is the whole dataset
%
%         twoBsol
%         Numerical scalar indicating which beam not to use in the 
%         calculation and force a two (for HADCP) or three-beam solution.
%         If this is zero, normal computation procedure is used (Default)
%
%         forceOrigin
%         {[]} | 'b' | 'i' | 's' | 'e'
%         Character to force the origin coordinate system (same conventions
%         as DESTCOR). If it is empty, it will read the origin coordinate
%         system from the data.
%         
%         isBt
%         {true} | false
%         Logical value indicating whether a non-hADCP measurement has
%         bottom-tracking data
% 
% 
%         Example: [adcp.VEL,adcp.btvel]=coradcp(adcp,'b','isUpward',true) will
%         transform velocity data to beam coordinates assuming an upward
%         looking ADCP
%
%         Notes: Three beams (or two beams for HADCP) solutions cannot be 
%                transformed back to beam coordinates (as it is not clear 
%                which beam failed).
%                All calculations and definitions
%                are based on "ADCP Coordinate transformation" manual by 
%                RDI (version February 2007). Refer to this manual for 
%                explanation on the computations
%
%         Author:      Bart Vermeulen, Maximiliano Sassi, Ton Hoitink,
%                      David Vermaas
%

%    Copyright 2008-2010 Bart Vermeulen, Maximiliano Sassi, Ton Hoitink, David Vermaas
%
%    This file is part of ADCPTools.
%
%    ADCPTools is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    ADCPTools is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with ADCPTools.  If not, see <http://www.gnu.org/licenses/>.


%         Last edit:  21-10-2010, derivation of heading from external 
%                     HeadBias made double
%         Last edit:  17-08-2010, calculation of pitch from raw tilts moved
%                     such that it's calculated before 180 degrees is added
%                     to the roll for upward looking case, added
%                     documentation for two and threebeam-solution

%         Last edit:  17-05-2010, 180 degrees are added also for HADCP,
%                     inverse matrix for beam to instrument is calculated
%                     by taking the transposed

%         Last edit:   10-07-2009 some minor corrections and cosmetics

%         Last edit:   08-07-2009
%         Last edit:   07-04-2008

%% Parsing input
P=inputParser;
P.addRequired('inadcp',@isstruct)
P.addRequired('DestCor',@(x) ischar(x) && numel(x)==1)
P.addParamValue('EnsRange',[1 1],@(x) isnumeric(x) && numel(x)==2 && x(2)>=x(1) && x(1)>0)
P.addParamValue('isHADCP',false,@islogical)
P.addParamValue('CalMatrix',zeros(4,4),@(x) isnumeric(x) && isequal(size(x),[4,4]))
P.addParamValue('OwnMatrix',zeros(4,4),@(x) isnumeric(x) && isequal(size(x),[4,4]))
P.addParamValue('BeamAngle',0,@(x) isnumeric(x) && x>0)
P.addParamValue('isUpward',false,@islogical)
P.addParamValue('useTilts',true,@islogical)
P.addParamValue('HeadAlign',0,@isnumeric)
P.addParamValue('HeadBias',0,@isnumeric)
P.addParamValue('ThreeBeams',true,@islogical)
P.addParamValue('UseExtHeading',false,@islogical)
P.addParamValue('Beam3Misalign',0,@(x) isnumeric(x) && numel(x)==1)
P.addParamValue('isBT',true,@islogical) % true when bottom track is present
P.addParamValue('forceOrigin',[],@(x) isempty(x) || (ischar(x) && isscalar(x) && any(strcmpi(x,{'b','i','s','e'}))) )
P.addParamValue('twoBsol',0,@(x) isnumeric(x) && numel(x) == 1 && x>=0 && x<=4 && mod(x,1)==0)
P.FunctionName='coradcp';
P.parse(inadcp,DestCor,varargin{:})

% EnsRange=P.Results.EnsRange;
isHADCP=P.Results.isHADCP;
OwnMatrix=P.Results.OwnMatrix;
BeamAngle=P.Results.BeamAngle;
isUpward=P.Results.isUpward;
useTilts=P.Results.useTilts;
HeadAlign=P.Results.HeadAlign;
HeadBias=P.Results.HeadBias;
%ThreeBeams=P.Results.ThreeBeams;
EnsRange=P.Results.EnsRange;
UseExtHeading=P.Results.UseExtHeading;
Beam3Misalign=P.Results.Beam3Misalign;
isBT = P.Results.isBT;
twoBsol = P.Results.twoBsol;
forceOrigin=P.Results.forceOrigin;

%% Check the fixed leader
%When the Fixed leader of the files differ, all setting are recorded once
%for each file. Sensitive parameters are the number of bins (because the
%variable leaders involving depth cell information will change in size) and
%any change in system or coordinate configuration.
nValidFiles = numel(inadcp.firmver);
if ~CheckFL(nValidFiles,inadcp)                                            % If configuration in fixed leader changes
%     warning('readadcp2:ConfigChange',...                                   % Generate warning
%         'The configuration seems to have changed between files. \n Using coradcp with maximum bin size') 
    idx = find(inadcp.nbins == max(inadcp.nbins),1,'first');                   % Create index for variable fixed leaders
else
    idx = 1;
end

nens=size(inadcp.VEL,2);
nbins=size(inadcp.VEL,1);
if any(strcmp(P.UsingDefaults,'EnsRange'))
    EnsRange = [1 nens];
end
Rangefilter=EnsRange(1):EnsRange(2);

%%  Check if water and BT velocity are converted to double already
if (~isfloat(inadcp.VEL))||(~isHADCP && isBT && ~isfloat(inadcp.btvel))
    error('Velocities should be converted to double first');
end

%% Determine type of transformation and generate matrices
if inadcp.sysconf(idx,4)==0     % Set c parameter to proper value p.11
    conv=-1; %concave
else
    conv=1;  %convex
end
if inadcp.corinfo(idx,3)=='1'   % Set flag: true if ADCP used tilts
    useTiltsADCP=true;
else
    useTiltsADCP=false;
end
if any(strcmp(P.UsingDefaults,'isUpward')) %If orientation not given, read it from the ADCP
    if inadcp.sysconf(idx,8)==0 %upward
        isUpward=true;
    end
end
if isUpward %For upward looking 180 degrees should be added to roll p.18
    addRoll=18000;
else
    addRoll=0;
end
if any(strcmp(P.UsingDefaults,'HeadAlign')) %Head alignment not given
    HeadAlign=double(inadcp.headalign); %use from adcp
else
    HeadAlign=repmat(HeadAlign,1,nValidFiles)*100;
end
if ~any(strcmp(P.UsingDefaults,'HeadBias')) %Head alignment is given
    inadcp.heading=double(inadcp.heading)-double(inadcp.headbias(idx))+HeadBias*100;   %Remove bias of ADCP and apply user defined one
end
if any(strcmp(P.UsingDefaults,'BeamAngle')) %If beam angle is not given read it from the ADCP
    if isHADCP
        alpha=inadcp.HADCPbeamangle(idx);        %For HADCP this is set in a special field
    else
        switch inadcp.sysconf(idx,9:10)         %For the others it is read from the system configuration
            case '00' %15E
                alpha=15;
            case '10' %20E
                alpha=20;
            case '11' %30E
                alpha=30;
            otherwise
                alpha=0;
        end
    end
else                    %If it is given take the given one!
    alpha=BeamAngle;
end
alpha=double(alpha)*pi/180; %Transform beam angle to Radians
if UseExtHeading
    rheading=getADCPHeading(inadcp)*100+Beam3Misalign*100;
    if any(strcmp('Beam3Misalign',P.UsingDefaults))
        warning('coradcp:ExtHeadNoMisalign','Unless external heading device and ADCP were perfectly aligned \n you should set a beam 3 misalignment!')        
    end
    if isempty(rheading)
        warning('coradcp:NoExtHeading','Could not find external heading, defaulting to heading in ADCP raw file')
        rheading=double(inadcp.heading);
    end
else
    rheading=double(inadcp.heading);
end

%for three beam solution, calculate missing one from the others (error vel.
%vanishes automatically


%% Construct transformation matrix to map from ADCP system to the given one
if any(strcmp(P.UsingDefaults,'OwnMatrix')) %If own transformation matrix not given calculate it!)
    TM=repmat(eye(4),[1,1,nens]);
    if ~isempty(forceOrigin)
        switch forceOrigin
            case 'b'
                inadcp.corinfo(idx,4:5)='00';
            case 'i'
                inadcp.corinfo(idx,4:5)='10';
            case 's'
                inadcp.corinfo(idx,4:5)='01';
            case 'e'
                inadcp.corinfo(idx,4:5)='11';
        end
    end
    % Determine current coordinate system
    switch inadcp.corinfo(idx,4:5)
    case '00' %beam
        switch DestCor
        case 'b' %beam to beam
            warning('corADCP:NoTrans','No transformation applied')
            VEL=inadcp.VEL(:,Rangefilter,:);
            if ~isHADCP && isBT
                btvel = inadcp.btvel(Rangefilter,:);
            end
            return
        case 'i' %beam to instrument
            TM=beam2instr(P,conv,alpha,isHADCP,0,twoBsol);
        case 's' %beam to ship
            TM=beam2instr(P,conv,alpha,isHADCP,0,twoBsol); 
            heading = HeadAlign(inadcp.FileNumber);%heading for instrument 2 ship coordinates (EA)
            TM=MatMult(HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTilts,nens,0),TM); %apply heading and tilts
        case 'e' %beam to earth
            TM=beam2instr(P,conv,alpha,isHADCP,0,twoBsol); %beam 2 instrument coordinates
            heading = rheading + HeadAlign(inadcp.FileNumber); %heading for instrument 2 earth (TH (H+EB) + EA) p. 18
            TM=MatMult(HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTilts,nens,0),TM); %apply heading and tilts
        end
    case '10' %instrument
        switch DestCor
        case 'b' %instrument to beam
            TM=beam2instr(P,conv,alpha,isHADCP,1,twoBsol);  %instrument 2 beam coordinates
        case 'i' %instrument to instrument
            warning('corADCP:NoTrans','No transformation applied')
            VEL=inadcp.VEL(:,Rangefilter,:);
            if ~isHADCP && isBT
                btvel = inadcp.btvel(Rangefilter,:);
            end
            return
        case 's' %instrument to ship
            heading = HeadAlign(inadcp.FileNumber);%heading for instrument 2 ship coordinates (EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTilts,nens,0); %apply heading and tilts
        case 'e' %instrument to earth
            heading = rheading + HeadAlign(inadcp.FileNumber); %heading for instrument 2 earth (TH (H+EB) + EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTilts,nens,0); %apply heading and tilts
        end
    case '01' %ship
        switch DestCor
        case 'b' %ship to beam
            heading = HeadAlign(inadcp.FileNumber);%heading for instrument 2 ship coordinates (EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTiltsADCP,nens,1); %apply inverse of heading and tilts
            TM=MatMult(beam2instr(P,conv,alpha,isHADCP,1,twoBsol),TM);  %beam 2 instrument coordinates
        case 'i' %ship to instrument
            heading = HeadAlign(inadcp.FileNumber);%heading for instrument 2 ship coordinates (EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTiltsADCP,nens,1); %apply inverse of heading and tilts
        case 's' %ship to ship
            warning('corADCP:NoTrans','No transformation applied')
            VEL=inadcp.VEL(:,Rangefilter,:);
            if ~isHADCP && isBT
                btvel = inadcp.btvel(Rangefilter,:);                
            end
            return
        case 'e' %earth
            heading = rheading; %heading for ship 2 earth (TH (H+EB))
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,0,nens,0); %apply heading and NO tilts
        end
    case '11' %earth
        switch DestCor
        case 'b' % earth to beam, instrument or ship
            heading = rheading + HeadAlign(inadcp.FileNumber); %heading for instrument 2 earth (TH (H+EB) + EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTiltsADCP,nens,1); %apply inverse of heading and tilts
            TM=MatMult(beam2instr(P,conv,alpha,isHADCP,1,twoBsol),TM);
        case 'i' % earth to instrument
            heading = rheading + HeadAlign(inadcp.FileNumber); %heading for instrument 2 earth (TH (H+EB) + EA)
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,useTiltsADCP,nens,1); %apply inverse of heading and tilts
        case 's' % earth to ship
            heading = rheading; %heading for instrument 2 ship (TH (H+EB))
            TM=HeadTilt(heading,inadcp.pitch,inadcp.roll,addRoll,0,nens,1); %apply inverse of heading and NO tilts
        case 'e' %earth
            warning('corADCP:NoTrans','No transformation applied')
            VEL=inadcp.VEL(:,Rangefilter,:);
            if ~isHADCP && isBT
                btvel = inadcp.btvel(Rangefilter,:);
            end
            return
        end
    end
else
    TM=OwnMatrix;
end
    
%% Transform velocity data (Processed for each bin seperately to save memory usage)
for cntbins=1:nbins
    Rangefilter=EnsRange(1):EnsRange(2);
    tempVEL= cat(1,reshape(inadcp.VEL(cntbins,Rangefilter,1),1,1,[]),reshape(inadcp.VEL(cntbins,Rangefilter,2),1,1,[]),reshape(inadcp.VEL(cntbins,Rangefilter,3),1,1,[]),reshape(inadcp.VEL(cntbins,Rangefilter,4),1,1,[]));
    tempVEL= MatMult(TM,tempVEL);
    inadcp.VEL(cntbins,Rangefilter,:)= cat(3,reshape(tempVEL(1,1,:),1,nens,1),reshape(tempVEL(2,1,:),1,nens,1),reshape(tempVEL(3,1,:),1,nens,1),reshape(tempVEL(4,1,:),1,nens,1));
end

% Output velocity data
VEL=inadcp.VEL(:,Rangefilter,:);

%% Transform BT velocity data (Processed for each bin seperately to save memory usage)
if ~isHADCP && isBT
    tempVEL = cat(1,reshape(inadcp.btvel(Rangefilter,1),1,1,[]),reshape(inadcp.btvel(Rangefilter,2),1,1,[]),reshape(inadcp.btvel(Rangefilter,3),1,1,[]),reshape(inadcp.btvel(Rangefilter,4),1,1,[]));
    tempVEL= MatMult(TM,tempVEL);
    % Output BT velocity data
    btvel = squeeze(tempVEL)';
else
    btvel = nan;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         End of the function                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%          FUNCTION TO COMPUTE TRANSFORMATION MATRIX
function biM=beam2instr(P,conv,alpha,isHADCP,isInv,twoBsol)
if any(strcmp(P.UsingDefaults,'CalMatrix')) %If no calibration matrix is given
    if alpha==0
        error('Could not find the beam angle in the raw data file! \n Please supply the angle through the property ''BeamAngle''');
    end
    if isHADCP %% Determine beam 2 instruments matrix for HADCP
        a=1/(2*sin(alpha));
        b=cos(alpha)/(1+2*cos(alpha)^2);
        c=1/(1+2*cos(alpha)^2);
        e1=1/(2*sin(alpha)*sqrt(1+2*cos(alpha)^2));
        e2=1/(tan(alpha)*sqrt(1+2*cos(alpha)^2));
        biM=[-a,       a,      0,      0;...
            -b,      -b,     -c,      0;...
            0,       0,      0,      0;...
            e1,      e1,    -e2,      0];        
        switch twoBsol % compute two-beam solution
            case 1 % beam 1
                biM = [0,2*a,-a*e2/e1,0;...
                    0,0,-b*e2/e1-c,0;...
                    0,0,0,0;...
                    0,0,0,0];
            case 2
                biM = [-2*a,0,a*e2/e1,0;...
                    0,0,-b*e2/e1-c,0;...
                    0,0,0,0;...
                    0,0,0,0];
            case 3
                biM = [-a,a,0,0;...
                    -b-c*e1/e2,-b-c*e1/e2,0,0;...
                    0,0,0,0;...
                    0,0,0,0];
        end
        if isInv %% Invert the matrix if needed (0 row and 0 collumn have to be removed for inversion)
            biM(3,:)=[];
            biM(:,4)=[];
            biM=inv(biM); %inversion if needed
            biM(4,:)=zeros(1,3);
            biM(:,4)=biM(:,3);
            biM(:,3)=zeros(4,1);
        end
    else    %% Determine beam 2 instruments matxix 4 beams adcp's
        a=1/(2*sin(alpha));
        b=1/(4*cos(alpha));
        d=a/sqrt(2);
        biM=[conv*a,   -conv*a,      0,     0;...
            0,      0,   -conv*a,   conv*a;...
            b,      b,      b,     b;...
            d,      d,     -d,    -d];
        switch twoBsol % compute three-beam solution
            case 1 % beam 1
                biM = [0,-2*a*conv,a*conv,a*conv;...
                    0,0,-a*conv,a*conv;...
                    0,0,2*b,2*b;...
                    0,0,0,0];
            case 2
                biM = [2*a*conv,0,-a*conv,-a*conv;...
                    0,0,-a*conv,a*conv;...
                    0,0,2*b,2*b;...
                    0,0,0,0];
            case 3
                biM = [a*conv,-a*conv,0,0;...
                    -a*conv,-a*conv,0,2*a*conv;...
                    2*b,2*b,0,0;...
                    0,0,0,0];
            case 4
                biM = [a*conv,-a*conv,0,0;...
                    a*conv,a*conv,-2*a*conv,0;...
                    2*b,2*b,0,0;...
                    0,0,0,0];
        end
        if isInv %% Invert the matrix if needed
            biM=inv(biM); %inversion if needed
        end
    end
else %%% otherwise P is the calibration matrix
    biM=P.Results.CalMatrix;
end

%%          FUNCTION TO COMPUTE ROTATION MATRIX
function htM=HeadTilt(heading, pitch, roll,addRoll, useTilts, nens,isInv)
% all angles shoud be given in centi-degrees (0.01)
if useTilts
    pitch=double(pitch)/100/180*pi;
    roll=double(roll)/100/180*pi;
    pitch=atan(tan(pitch).*cos(roll));    
    roll=roll+addRoll/100/180*pi;
else
    pitch=zeros(1,1,nens);
    roll=zeros(1,1,nens);
end
heading=double(heading)/100/180*pi;
sh=reshape(sin(heading),1,1,[]);
ch=reshape(cos(heading),1,1,[]);
sp=reshape(sin(pitch),1,1,[]);
cp=reshape(cos(pitch),1,1,[]);
sr=reshape(sin(roll),1,1,[]);
cr=reshape(cos(roll),1,1,[]);
htM = [ch.*cr+sh.*sp.*sr,  sh.*cp,          ch.*sr-sh.*sp.*cr,  zeros(1,1,nens);...
       -sh.*cr+ch.*sp.*sr, ch.*cp,          -sh.*sr-ch.*sp.*cr, zeros(1,1,nens);...
       -cp.*sr,            sp,              cp.*cr,             zeros(1,1,nens);...
       zeros(1,1,nens),    zeros(1,1,nens), zeros(1,1,nens),    ones(1,1,nens)];
if isInv, htM=permute(htM,[2,1,3]);end

%%          FUNCTION TO MULTIPLY MATRICES ALONG 3rd DIMENSION
function MM=MatMult(A,B)
% Multiply matrices along third dimension
nrows=size(A,1);
ncols=size(B,2);

indim=size(A,2);
if indim~=size(B,1)
    error('MatMult:InDim','Inner matrix dimensions should agree')
end
n3=max(size(A,3),size(B,3));
if (size(A,3)~=size(B,3)) && size(A,3)~=1 && size(B,3)~=1
    error('MatMult:Wrong3dim','Third dimension size must be equal or \n at least one variable must have third dimension size equal to one')
end
MM=zeros(nrows,ncols,n3);
for cntrow=1:nrows
    for cntcol=1:ncols
        for cntdim=1:indim
               MM(cntrow,cntcol,:)=MM(cntrow,cntcol,:)+A(cntrow,cntdim,:).*B(cntdim,cntcol,:);
        end
    end
end

%%          FUNCTION TO CHECK DIFFERENCES IN FIXED LEADER (from readadcp2)
function issame=CheckFL(nValidFiles,dataout)

issame=true;                                                               % Initialize result as true
if nValidFiles<2                                                           % If less than two files
    issame=true;                                                           % Return true
    return                                                                 % Exit function (Nothing to check!!)
end
for cntfiles=2:nValidFiles                                                 % Loop for all files
    issame=issame &&...                                                    % Check if any of the variables changes
        isequal(dataout.firmver(1),dataout.firmver(cntfiles))&&...
    isequal(dataout.firmrev(1),dataout.firmrev(cntfiles))&&...
    isequal(dataout.sysconf(1,:),dataout.sysconf(cntfiles,:))&&...
    isequal(dataout.SymData(1),dataout.SymData(cntfiles))&&...
    isequal(dataout.LagLength(1),dataout.LagLength(cntfiles))&&...
    isequal(dataout.usedbeams(1),dataout.usedbeams(cntfiles))&&...
    isequal(dataout.nbins(1),dataout.nbins(cntfiles))&&...
    isequal(dataout.pingperens(1),dataout.pingperens(cntfiles))&&...
    isequal(dataout.binsize(1),dataout.binsize(cntfiles))&&...
    isequal(dataout.blnk(1),dataout.blnk(cntfiles))&&...
    isequal(dataout.minthrsh(1),dataout.minthrsh(cntfiles))&&...
    isequal(dataout.ncodrep(1),dataout.ncodrep(cntfiles))&&...
    isequal(dataout.minpercgood(1),dataout.minpercgood(cntfiles))&&...
    isequal(dataout.maxerrvel(1),dataout.maxerrvel(cntfiles))&&...
    isequal(dataout.Tbetweenpng(1),dataout.Tbetweenpng(cntfiles))&&...
    isequal(dataout.corinfo(1,:),dataout.corinfo(cntfiles,:))&&...
    isequal(dataout.headalign(1),dataout.headalign(cntfiles))&&...
    isequal(dataout.headbias(1),dataout.headbias(cntfiles))&&...
    isequal(dataout.sensource(1,:),dataout.sensource(cntfiles,:))&&...
    isequal(dataout.senavail(1,:),dataout.senavail(cntfiles,:))&&...
    isequal(dataout.distmidbin1(1),dataout.distmidbin1(cntfiles))&&...
    isequal(dataout.lngthtranspulse(1),dataout.lngthtranspulse(cntfiles))&&...
    isequal(dataout.watrefbins(1,:),dataout.watrefbins(cntfiles,:))&&...
    isequal(dataout.mintarget(1),dataout.mintarget(cntfiles))&&...
    isequal(dataout.lowlattrig(1),dataout.lowlattrig(cntfiles))&&...
    isequal(dataout.distpulse(1),dataout.distpulse(cntfiles))&&...
    isequal(dataout.cpuserial(1,:),dataout.cpuserial(cntfiles,:))&&...
    isequal(dataout.bandwidth(1),dataout.bandwidth(cntfiles))&&...
    isequal(dataout.syspower(1),dataout.syspower(cntfiles))&&...
    isequal(dataout.basefreqid(1),dataout.basefreqid(cntfiles))&&...
    isequal(dataout.serial(1,:),dataout.serial(cntfiles,:))&&...
    isequal(dataout.HADCPbeamangle(1),dataout.HADCPbeamangle(cntfiles));
    if issame==false
        break
    end
end
